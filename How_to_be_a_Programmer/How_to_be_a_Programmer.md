# 程序员的自我修养

## 编译与链接

编译程序一般可分解为4个步骤：预处理、编译、汇编和链接；

预编译是将源代码和相关的头文件用预编译器cpp预编译成一个i文件。第一步预编译的过程相当于如下命令（-E表示只进行预编译）：

```shell
gcc -E hello.c -o hello.i
```

预编译过程主要处理那些以"#"开始的预编译指令，比如"#include"、"#define"等，如下：

- 将所有“#define”删除，并且展开所有的宏定义；
- 处理所有的条件预编译指令，如#if等；
- 处理#include预编译指令，将被包含的文件插入到该预编译指令的位置；
- 删除所有的注释，如//；
- 添加行号和文件名标识；
- 保留所有的#pragma编译器指令；

经过预编译的.i文件不包含任何宏定义，并且包含的文件也已经插入到.i文件中。

编译过程是把预处理的文件经过一系列的语法分析、词法分析最终生成汇编代码文件，这个编译过程相当于以下命令：

```shell
$gcc -S hello.i -o hello.s
```

现在版本的GCC将预编译和编译合成一个步骤，使用ccl的程序来完成，位于`/user/lib/gcc/i486-linux-gnu/4.1/`中，c语言叫做ccl，而c++交过cclplus。

汇编则是将汇编代码转换成为机器指令，每一条汇编语句几乎都对应一条机器指令，过程相当于如下的命令：

```shell
$gcc -c hello.s -o hello.o
```

链接这个过程相对复杂，通过以下的内容来介绍。编译器其实就是将高级语言翻译成机器语言的工具。比如有一行C语言的源码：

```c
array[index] = (index + 4) * (2 + 6);
```

首先要进行词法分析，代码被输入到扫描器，源代码的字符序列被分割成一系列的记号。词法分析产生的记号一般可以分为以下几类：关键字、标识符、字面量（包含数字、字符串等）和特殊符号（如等号加号），在识别记号的同时，扫描器也完成了其他工作，比如将标识符放到符号表，将数组、字符串常量存放到文字表等。

接下来是语法分析，语法分析器将对扫描器产生的记号进行语法分析，从而产生语法树，整个分析过程采用上下文无关语法。

语法分析完成会进行语义分析，编译器所能分析的语义是静态语义，即在编译期可以确定的语义，与之对应的是动态语义，即只有在运行期才能确定的语义。静态语义通常包括声明和类型的匹配，类型的转换等。

之后还会进行多层级的优化，比如源代码优化、代码生成和目标代码优化，编译器会将源代码翻译成目标代码。

下面来解释链接这个过程。首先解释以下重定位的定义，即重新计算各个目标的地址的过程。符号则用来表示一个地址，可能是一段子程序的起始地址，也可能是一个变量的起始地址。现代的程序规模都很庞大，其会被分割成为多个模块，这些模块之间如何组合形成一个单一的程序是必须解决的问题。模块组合的问题又可以归结为模块之间如何通信，比如跨模块的函数调用或者变量访问，这可以归结成一种方式，那就是模块间的符号引用。这类似于拼图，定义符号的模块多出一块区域，而引用该符号的模块刚好少了一块区域，这种模块的拼接过程就是链接。因此，组装模块的过程就是链接。链接的过程主要包括地址和空间分配、符号决议和重定位等。

最基本的静态链接很简单，每个模块的源代码文件经过编译成为目标文件，目标文件和库一起链接形成最终可执行文件。最常见的库是运行时库，它是支持程序运行的基本函数的集合。现代的编译和链接也没有那么复杂，当我们在模块main.c中使用另一个模块func.c中的函数foo()，我们在每一处调用foo的时候都必须确切知道这个foo的地址，由于每个模块都是单独编译的，因此编译器在编译main.c的时候并不知道foo的地址，这个时候会暂时把这些调用foo的指令的目标地址搁置，等到最后链接的时候由连接器将这些指令的目标地址修正。

## 目标文件里面有什么

编译器编译源代码后生成的文件叫做目标文件，目标文件从结构上讲，是已经编译后的可执行文件格式，只是还没有经过链接的过程，其中可能有些符号或有些地址还没有被调整，但其本身就是按照可执行文件格式存储的。

现在PC流行的可执行文件格式主要是Windows下的PE和Linux下的ELF，它们都是COFF格式的变种。不光是可执行文件安装可执行文件格式存储，动态链接库跟静态链接库都按照可执行文件来存储，静态链接库稍微有点不同，其是把很多目标文件捆绑在一起形成一个文件，再加上一些索引，所以可以简单将其理解为一个包含很多文件的文件包。linux下可以使用file命令来查看文件格式。

目标文件中除了编译后的机器指令代码、数据之外，还包括了连接时所需要的一些信息，比如符号表、调试信息、字符串等，一般这些信息以节的形式存储，有时候也叫做段。源代码编译后的机器指令经常被放在代码段，代码段常见的名字有.code或.text，全局变量和局部静态变量数据经常放在数据段，数据段的名字一般叫做.data。ELF文件的开头是一个文件头，它描述了整个文件的文件属性，包括文件是否可执行、是静态链接还是动态链接及入口地址、目标硬件、目标操作系统等，文件头还包括一个段表，其是一个描述文件中各个段的数组，段表描述了文件中各个段在文件中的偏移位置及段的属性等，从段表里可以得到每个段的所有信息。一般C语言中已初始化的全局变量和局部静态变量都保存在.data段，未初始化的全局变量和局部静态变量一般放在一个.bss的段里。由于未初始化的全局变量和局部静态变量默认值都为0，所以在.data段分配空间并存放数据0是没有必要的，但又必须记录所有未初始化的全局变量和局部静态变量的大小总和，因此记为.bss段，它只是为未初始化的全局变量和全局静态变量预留位置，并没有内容，所以也不占据空间。

为什么要将指令和数据分开存放呢，主要有以下几个好处：

- 数据和指令被映射到两个虚拟区域，数据区域对于进程来说是可读写的，而指令区域对于进程来说是只读的，这样可以防止指令被改写；
- 现代CPU的缓存一般都被设计为数据缓存和指令缓存分离，因此指令和数据分开存放对CPU的缓存命中率提高有好处；
- 第三个原因是最重要的，那就是当系统运行着多个该程序的副本是，由于指令一样，所以内存中需要保存一份指令即可，但数据是各进程独享的。

如果想要看目标文件是什么样子，可以通过`objdump -h xxx.o`来查看。针对elf文件格式，linux还有一个readelf工具。除了代码段、数据段以及BSS段之外，还有只读数据段、注释信息段以及堆栈提示段，这几个段暂且不管，先研究下几个段的属性。其中最容易理解的是段的长度和段所在的位置，每个段第二行的CONTENTS、ALLOC等表示段的各种属性，CONTENTS表示该段在文件中存在。size命令可以查看elf文件的代码段、数据段和BSS段的长度。

挖掘各个段的内容，离不开objdump，-s参数可以将所有段的内容以十六进制的方式打印出来，-d参数可以将所有包含指令的段反汇编。

.rodata段存放的是只读数据，一般是程序里面的只读变量（如const修饰的变量）和字符串常量，有了这个字段，不光是在语义上支持了C++的const关键字，而且操作系统在加载的时候可以将其映射成只读，保证程序的安全性。另外需要注意的是，有的编译器会将字符串常量放到.data段。有时我们需要指定某些东西放在指定的段，比如为了满足某些硬件的内存和IO的地址布局，GCC提供了一个扩展机制，使得程序员可以指定变量所处的段：

```c++
__attribute__((section("FOO"))) int global = 42;
__attribute__((section("BAR"))) void foo()
{

}
```

在全局变量或函数之前加上"\_\_attribute\_\_((section("name)))"属性就可以把相应的变量或函数放到以name作为段名的段中。

下面讨论ELF文件结构，可以使用readelf命令来查看ELF文件。ELF的文件头中定义了ELF魔数、文件机器字节长度、数据存储方式、版本、运行平台、ABI版本、ELF重定位类型、硬件平台、硬件平台版本、入口地址、程序头入口和长度、段表的位置和长度以及段的数量等。ELF文件头结构以及相关常数被定义在"/usr/include/elf.h"里，因为elf文件在各个平台都通用，因此ELF文件有32和64位两个版本，分别为Elf32_Ehdr和Elf64_Ehdr。32版本和64版本的ELF文件的文件头内容是一样的，只不过有些成员的大小不一样。为了对每个成员的大小做出明确规定以便在不同的编译环境下都拥有相同的字段长度，elf.h使用typedef定义了一套自己的变量体系。

- ELF魔数：最前面的16个字节刚好对应Elf32_Ehdr的e_ident这个成员，这16字节被用来表示ELF文件的平台属性。这种魔数用来确认文件的类型，操纵系统在加载可执行文件的时候会确认魔数是否正确，如果不正确会拒绝加载；
- 文件类型：e_type成员表示ELF文件类型，系统通过这个常量判断ELF的真正文件类型，而不是文件的扩展名；
- 机器类型：使用e_machine成员表示；

段表是保存段的基本属性的结构，是除了文件头之外最重要的结构，其描述了ELF各个段的信息，比如每个段的段名、长度、在文件中的偏移、读写权限及段的其他属性，因此elf文件的段结构就是由段表决定的，编译器、链接器和装载器都是依靠段表来定位访问各个段的属性的，段表在ELF文件中的位置由elf文件头的e_shoff成员决定。可通过readelf命令来查看段表，段表的结构也比较简单，是一个以Elf32_Shdr结构体为元素的数组，数组元素等于等于段的个数，每个Elf32_Shdr结构体对应一个段，Elf32_Shdr又被称为段描述符。

段的名字只是在链接和编译过程中有意义，但不能真正表示段的类型，对于编译器和链接器来说，主要决定段的属性的是段的类型和段的标志位。段的标志位表示该段在进程虚拟地址空间中的属性，比如是否可写是否可执行等。

重定位表记录了代码段和数据段中那些对绝对地址引用的位置。字符串表记录了要使用的字符串。

在链接中，将函数和变量统称为符号，函数名或变量名就是符号名。每一个目标文件都会有一个相应的符号表，这个表里面记录了目标文件所用到的所有符号，每个定义的符号有一个对应的值叫做符号值，对于变量和符号来说，符号值就是它们的地址。符号表的符号可能是以下的类型：

- 定义在本目标文件中的全局符号，可以被其他目标文件引用；
- 在本目标文件中引用的全局符号，但没有定义在本目标文件；
- 段名，往往由编译器产生，其值就是该段的起始地址；
- 局部符号，只在编译单元内部可见；
- 行号信息；

我们可以使用nm命令来查看符号表。

ELF文件中的符号表往往是文件中的一个段，叫做.symtab，符号表的结构很简单，其是一个Elf32_Sym结构的数组，每个Elf32_Sym结构对应一个符号。数组的第一个元素为无效的未定义的符号。Elf32_Sym的结构如下所示：

```c++
typedef struct {
	Elf32_Word st_name;
	Elf32_Addr st_value;
	Elf32_Word st_size;
	unsigned char st_info;
	unsigned char st_other;
	Elf32_Half st_shndx;
} Elf32_Sym;
```

使用ld作为链接器来链接生产可执行文件时会产生很多特殊的符号，这些符号被成为特殊符号，我们可以直接声明并引用，以下是几个比较常见的：

- __executable_start，程序起始地址；
- \_\_etext或\_etext或etext，代码段结束地址；
- \_edata或edata，数据段结束地址；
- _end或end，程序结束地址；

为了应付重载等功能，人们发明了符号修饰或符号改编机制。无论是函数重载还是使用命名空间区分不同的函数，它们的函数名是相同的，为此，引入了函数签名来区分。函数空间包含了一个函数的信息，包括函数名、参数类型、它所在的类和名称空间及其他信息，说白了，函数签名就是用于识别不同的函数。在编译器以及链接器处理符号时，它们使用某种名称修饰，使得每个函数签名对应一个修饰后名称。GCC的基本C++名称修饰规则如下：所有的符号都以_Z开头，对于嵌套的名字（在命名空间或在类里面），后面紧跟着N，然后是各个命名空间和类的名字，每个名字前是名字字符串长度，再以E结尾。binutils里面提供了一个c++filt工具，可以解析被修饰的名称。C++中的全局变量和静态变量也有同样的机制，对全局变量来说也遵循上面的规则，但变量的类型没有被加入修饰后的名称。

C++为了与C兼容，有一个用来声明或定义一个C的符号"extern C"的关键字用法。这会将其作用域内的代码当作C语言代码处理，C++的名称修饰将不会起作用。如果单独声明某个变量或函数为C的符号，可以使用如下的格式：

```c++
extern "C" int func(int);
extern "C" int var;
```

由于C语言不支持"extern C"语法，为了C++跟C的兼容性，C++引入了宏"__cplusplus"，如下：

```c++
#ifdef __cplusplus
extern "C" {
#endif
void *memset(void*, int, size_t);
#ifdef __cplusplus
}
#endif
```

如果当前编译单元是C++代码，则memset在extern C中被声明，如果是C代码则直接声明。

如果多个目标文件中含有相同名字的全局符号的定义，那么在链接的时候将会出现符号重复定义的错误。这种符号的定义称为强符号，而有些符号的定义称为弱符号，对C++/C来说，编译器默认函数和初始化了的全局变量为强符号，未初始化的全局变量为弱符号。也可以通过GCC的"\_\_attribute\_\_((weak))"来定义任何一个强符号为弱符号。注意，强符号和弱符号都是针对定义来说的，不是针对符号的引用，比如：

```c++
extern int ext;
int weak;
int strong = 1;
__attribute__((weak)) weak2 = 2;
int main() {
	return 0;
}
```

ext既非强符号也非弱符号，因为它是一个外部变量的引用。针对强弱符号的概念，链接器会安装如下规则处理多次定义的全局符号：

1. 不允许强符号被多次定义；
2. 如果一个符号在某个目标文件中是强符号，在其他文件中是弱符号，那么选择强符号；
3. 如果一个符号在所有的目标文件中都是弱符号，那么选择其中占用空间最大的一个；

如果在链接的时候，没有找到符号的定义，链接器报符号未定义错误，这种被称为强引用。当处理弱引用，如果该符号有定义则决议，如果该符号未被定义，则链接器对于该引用不报错。一般对于未定义的弱引用，链接器默认其为0或者是一个特殊的值，以便程序代码能够识别。在GCC中，通过"\_\_attribute\_\_((weakref))"这个扩展关键字来声明一个外部函数的引用为弱引用。

目标文件里还有可能保存调试信息。

## 静态链接

链接器在生成可执行文件的过程中，如何将各个段合并到输出文件？一个最简单的方案是按序叠加，但这样会导致输出文件有很多零散的段，这样会非常浪费空间，因为每个段都有一定的地址和空间对齐要求。一个更实际的方法是将相同性质的段合并到一起，比如所有输入文件的.text段。.bss段在目标文件和可执行文件中并不占用文件空间，但它在装载时占用地址空间，所以链接器在合并各个段的同时也将.bss合并，并且分配地址空间。链接器对目标文件分配地址和空间实际包含两个含义，一个是在输出的可执行文件中的空间，一个是装载后的虚拟地址中的虚拟地址空间。对于有实际数据的段，比如.text和.data来说，它们在文件中和虚拟地址中都要分配空间，因为它们在这两者中都存在，但对于.bss来说，分配空间的意义只局限于虚拟地址空间，因为它们在文件中并没有内容。事实上，这里谈到的空间分配只关注于虚拟地址空间的分配。目前链接器空间分配的策略一般采用的一种叫两步链接的方法：

1. 空间与地址分配：扫描所有输入目标文件，获得它们的各个段的长度、属性和位置，并且将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统一放到一个全局符号表。这一步，链接器能获得所有输入目标文件的段长度，并且将它们合并，计算出输出文件中各个段合并后的长度与位置，并建立映射关系；
2. 符号解析与重定位：使用第一步收集的信息，读取输入文件中段的数据、重定位信息，并进行符号解析和重定位、调整代码中的地址等；

第一步会将各个段的地址重新映射，完成之后链接器开始计算各个符号的虚拟地址，根据每个段的虚拟地址重新进行映射。之后就进入了符号解析与重定位的步骤，这也是静态链接的核心内容。比如说某个文件引用其他文件的变量跟函数，当编译时，可能会把引用变量的地址暂用0x00000000来代替，引用函数相对复杂，是相对下一条指令的偏移，暂用0xFFFFFFFC代替。当真正链接时才会将这些地址替换为真实的地址。那么链接器是如何知道哪些指令需要调整，指令的哪些部分需要调整，这主要依赖于ELF文件中的重定位表。每个要被重定位的ELF段都有一个对应的重定位表，而一个重定位表往往都是ELF文件中的一个段，所以重定位表可以叫做重定位段。比如代码段如果有要被重定位的地位，那么会有一个对应的.rel.text的段保存了代码段的重定位表。objdump -r xxx可以查看目标文件要被重定位的地方。每个要被重定位的地方叫做重定位入口，重定位入口的偏移表示该入口要在被重定位的段中的位置。重定位的过程中，每个重定位的入口都是对一个符号的引用，当重定位时，链接器会查找由所有输入目标文件的符号表组成的全局符号表，找到相应的符号后进行重定位。

弱符号机制允许同一个符号的定义存在于多个文件中，那么如果这个符号的类型各有不同怎么办？其主要分为以下几种情况：

- 两个或两个以上的强符号类型不一致；
- 有一个强符号，其他都是弱符号，出现类型不一致；
- 两个或两个以上弱符号类型不一致；

第一种情况违法不讨论，因此要处理的就是后面的情况。事实上现在编译器和链接器现在都支持一种叫做COMMON块的机制，早先程序员必须事先声明其所临时使用的空间的大小，当不同的目标文件需要的COMMON块空间大小不一致时，以最大的那块为准。现代链接机制处理弱符号时采用相同的机制，当出现多个弱符号的情况下，其大小以最大的那个为准。如果其中一个是强符号，那么会以强符号为准，但如果有弱符号大小大于强符号，ld链接器会报告警告。这也就解释了以下的问题，那就是未初始化的全局变量在编译时未知大小，所以不能像跟未初始化的局部静态变量一样放在BSS段。GCC的“-fno-common”也允许我们把所有未初始化的全局变量不以COMMON块的形式处理，或使用"\_\_attribute\_\_"扩展：

```c++
int global __attribute__((nocommon));
```

一个未初始化的变量不是以COMMON块的形式存在，那么它就是一个强符号。

C++编译器在很多时候会产生重复的代码，比如模板、外部内联函数和虚函数表都可能在不同的编译单元产生相同的代码。一个有效的做法是将每个目标的实例代码单独存在一个段里，每个段只包含一个模板实例，当链接时就可以根据名字区分将它们合入到最后的代码段。对于外部内联函数和虚函数表的做法也类似。VISUAL C++编译器提供了一个函数级别链接的选项，可以让最终链接时只合并有用的函数，无用的则抛弃，GCC也提供了类似的机制，它有两个选择分别是"-ffunction-sections"和"-fdata-section"。

有一些特定的操作必须在main函数之前执行，有些必须是在main之后执行，其中最具代表的是C++的全局对象的构造和析构函数，因此ELF文件还定义了两种特殊的段：

- .init，该段保存的是可执行指令，它构成了进程的初始化代码；
- .fini，该段保存进程终止代码指令，当main函数正常退出时，Glibc会安排执行这个段中的代码；

如果想要两个编译器编译出的目标文件能够相互链接，那么目标文件必须满足以下条件：采用同样的目标文件格式、拥有同样的符号修饰标准、变量的内存分布方式相同、函数的调用方式相同等等。其中我们把符号修饰标准、变量内存布局、函数调用方式这些跟可执行代码二进制兼容性相关的内容称为ABI。比如对应C语言的代码，以下几个方面会决定目标文件之间是否二进制兼容：

- 内置类型（如int、float、char等）的大小和在存储器中的放置方式（大端、小端、对齐方式等）；
- 组合类型（如struct、union、数组等）的存储方式和内存分布；
- 外部符号与用户定义的符号之间的命名方式和解析方式，如函数名func在C中的目标文件中是否被解析成外部符号_func。
- 函数调用方式，比如参数入栈顺序，返回值如何保持等；
- 堆栈的分布方式，比如参数和局部变量在堆栈里的位置，参数传递方法等；
- 寄存器使用约定，函数调用时哪些寄存器可以修改，哪些需要保存等；

C++对ABI的影响又增加了许多新的内容：

- 继承类体系内的内存分布，如基类、虚基类在继承类中的位置等；
- 指向成员函数的指针的内存分布，如何通过指向成员函数的指针来调用成员函数，如何传递this指针；
- template如何实例化；
- 外部符号的修饰；
- 全局对象的构造和析构；
- 异常的产生和捕获机制；
- 标准库的细节问题，RTTI如何实现等；
- 内嵌函数访问细节；

目前基本形成了微软的VISUAL C++和GUN的GCC为首的两大派系。

一个程序必然会有输入和输出，那么最简单的方式就是调用系统提供的api。一般情况下，一种语言的开发环境往往会附带语言库，这些库就是对操作系统的API的包装。一个静态库可以简单看作一组目标文件的集合，即很多目标文件经过压缩打包后形成的一个文件。比如在linux最常用的c语言静态库位于/usr/lib/libc.a，它属于glic项目的一部分。libc.a中包含了大量我们所需要的目标文件，为了管理和组织的方便，人们使用了ar压缩程序将其压缩，并进行编号和索引，最终形成了libc.a这个静态库。我们可以使用ar工具来查看静态库包含了哪些目标文件，如`ar -t libc.a`。目标文件有很多，我们怎么找到例如printf函数所在的目标文件呢，答案是使用objdump或readelf加上grep。

有时候我们需要对链接过程进行控制，一般来说链接器有如下三种方法：

- 使用命令行来给链接器指定参数，如ld的参数-o、-e等；
- 将链接指令存放到目标文件中；
- 使用链接控制脚本；

可以使用以下的命令行来查看Ld默认的链接脚本：`ld -verbose`；默认的ld链接脚本存放在/usr/lib/ldscripts/下。如果我们想要自己指定链接脚本可以使用-T参数，如`ld -T link.script`。

我们有以下链接的示例：

```c++
char *str = "Hello world!\n";
void print() {
	asm("movl $13,%%edx \n\t"
		"movl %0,%%ecx \n\t"
		"movl $0,%%ebx \n\t"
		"movl $4,%%eax \n\t"
		"int $0x80     \n\t"
		::"r"(str):"edx","ecx","ebx");
}
void exit() {
	asm("movl $42,%ebx  \n\t"
		"movl $1,%eax   \n\t"
		"int $0x80      \n\t");
}

void nomain() {
	print();
	exit();
}
```

易见，程序入口为nomain，这里print使用了linux的write系统调用，exit使用了exit的系统调用，这里使用了GCC的内嵌汇编。这里简单介绍下系统调用，通过0x80中断实现，其中eax为调用号，ebx、ecx、edx等通用寄存器用来传递参数。这里先使用命令来编译链接TinyHelloWorld.c：

```shell
gcc -c -fno-builtin TinyHelloWorld.c
ld -static -e nomain -o TinyHelloWorld TinyHelloWorld.o
```

其中参数意义如下：

- -fno-builtin：GCC会把一些常用的C库函数替换成编译器的内置函数以达到优化的目的，使用此参数关闭此功能；
- -static：ld使用静态链接的方式链接程序；
- -e：表明入口函数为nomain；
- -o：指定输出的可执行文件；

现在来看下链接脚本TinyHelloWorld.lds：

```shell
ENTRY(nomain)
SECTIONS
{
	. = 0x08048000 + SIZEOF_HEADERS;
	tinytext : { *(.text) *(.data) *(.rodata)}
	/DISCARD/ : { *(.comment) }
}
```

第一行的ENTRY指定了程序的入口，后面的SECTIONS命令是链接脚本的主体，指定了各种输入段到输出段的变换。第一条是赋值语句，将当前虚拟地址设为Ox08048000 + SIZEOF_HEADERS，SIZEOF_HEADERS为输出文件的文件头大小，第二条是将所有输入文件中的名字中为.text、.data或.rodata的段依次合并到输出文件的tinytext，第三条是将所有输出文件中名字为.comment的段丢弃。通过以下的命令来编译并启动链接脚本：

```shell
gcc -c -fno-builtin TinyHelloWorld.c
ld -static -T TinyHelloWorld.lds -o TinyHelloWorld TinyHelloWorld.o
```

当使用readelf工具查看时，会发现除了tinytext之外还有其他三个段：.shstrtab、.symtab和.strtab，分别为段名字符串表、符号表以及字符串表，默认情况下ld链接器在产生文件时会产生这三个段，对于可执行文件来说，符号表和字符串表是可选的，但是段名字符串表用户保存段名，所以是必不可少的。可以通过ld的-s参数禁止产生符号表，或者使用strip命令去除程序中的符号表。

## 可执行文件的装载与进程

一般来说，C语言指针大小的位数和虚拟空间的位数相同，如32位平台下的指针为32位，即4字节大小。以32位的系统为例，整个4G的空间被划分成了两部分，其中操作系统本身用去了一部分：从0xC0000000到0xFFFFFFFF共1GB，剩下的从0x00000000到0xBFFFFFFF都是留给进程使用。

很多情况下程序所需要的内存数量大于物理内存的数量，当内存的数量不够时，人们开始研究在不添加内存的情况下使得程序运行起来，更有效的利用内存。后来研究发现，程序运行时有局部性的原理，所以我们可以将程序最常用的部分驻留在内存中，而将一部分不常用的数据放在磁盘里面，这就是动态装入的基本原理。覆盖装入和页映射是两种典型的动态装载方法，它们的思想都近似，即利用程序的局部性原理，用到哪个模块就装入内存，不用就暂时不装入，存放在磁盘。

覆盖装入要求程序员必须手工将程序分为若干块，然后编写一个小的辅助代码管理这些模块何时应该驻留内存何时应该被替换，这个小的辅助代码就是所谓的覆盖管理器。

页映射则是将内存和所有磁盘中的数据和指令按照页为单位划分成若干页，以后装载和操作的单位都是页，然后根据需要在内存中动态装载所需要的页。

进程的建立从以下三件事情开始：

- 创建一个独立的虚拟地址空间；
- 读取可执行文件头，并且建立虚拟空间和可执行文件的映射关系；
- 将CPU的指令寄存器设置成可执行文件的入口地址，启动运行；

首先是创建虚拟地址空间，一个虚拟空间是由一组页映射函数将虚拟空间的各个页映射至相应的物理空间，那么创建一个虚拟空间实际上并不是创建空间而是创建映射函数所需要的相应的数据结构，在i386的linux下，创建虚拟地址空间实际上只是分配一个页目录就可以了，甚至不设置页映射关系，这些映射关系等到后面程序发生页错误再进行设置。

读取可执行文件头，建立虚拟空间和可执行文件的映射关系。我们知道，当发送页错误时，操作系统会从物理内存中分配一个物理页，然后将该缺页从磁盘读取到内存中，再设置缺页的虚拟页和物理页的映射关系，这样程序才得以正确运行。很明显的一点，当系统捕获到缺页错误时，它应当知道程序当前需要的页在可执行文件的哪一个位置，这就是虚拟空间与可执行文件之间的映射关系，某种程度上这是整个装载过程中最重要的一步，也是传统意义上装载的过程。Linux将进程虚拟空间中的一个段叫做虚拟内存区域（VMA），在windows中将其叫做虚拟段。

将CPU指令寄存器设置成可执行文件入口，启动运行是最简单的一步，系统通过设置CPU的指令寄存器将控制权转交给进程，由此进程开始执行。

操作系统装载可执行文件，其实并不关心可执行文件各个段包含的实际内容，其只关心一些跟装载有关的问题，最主要的是段的权限，在ELF文件中，基本上是以下三种：

- 以代码段为代表的权限为可读可执行的段；
- 以数据段和BSS段为代表的权限为可读可写的段；
- 以只读数据段为代表的权限为只读的段；

那么很显然，对于相同权限的段，可以合并到一起当作一个段进行映射。可以使用readelf命令来查看ELF的段，描述section属性的结构叫做段表，描述segment的结构叫做程序头，使用如下命令：readelf -l SectionMapping.elf。

在操作系统中，VMA除了被用来映射可执行文件中的各个segment以外，还有其他的作用。事实上，栈、堆等空间在进程的虚拟空间中的表现也是以VMA的形式存在的。很多情况下，一个进程中的栈和堆分别都有一个对应的VMA。在linux下，可通过proc来查看进程的虚拟空间分布：

```shell
$./SectionMapping.elf &
21963
$cat /proc/21963/maps
```

Linux下虚拟空间分给进程本身的是3G（Windows默认是2G），那么程序最多可以申请多少，linux大概是2.9G左右，windows大概是1.5G，malloc的最大申请数量要受到操作系统版本、程序本身大小、用到的动态/共享库数量、大小、程序栈数量、大小等。

装载的过程一般是通过虚拟内存的页映射机制完成，页是映射的最小单位，也就是说要在一段物理内存和进程虚拟地址空间之间建立映射关系，这段内存空间的长度必须是4096的整数倍，并且这段空间在物理内存和进程虚拟地址空间的起始地址必须是4096的整数倍。如果直接映射的话，各个段很有可能有许多内部碎片，浪费内存空间，有些UNIX系统采用了一个取巧的方法，将各个段的接壤部分共享一个物理节目，然后将该物理页面分别映射两次。

进程刚启动的时候，需要知道一些进程运行的环境，最基本的就是系统环境变量和进程运行参数，很常见的做法是在进程启动前将这些信息提前保存到进程的虚拟空间的栈中。

Linux要执行某个ELF程序，bash进程会调用fork创建一个新的进程，然后新的进程调用execve系统调用执行ELF文件，原先的bash进程继续返回等待刚才启动的新进程结束，然后继续等待用户输入命令。execve系统调用相应的入口是sys_execve，它在进行一些参数的检查复制之后会调用do_execve，do_execve会首先查找被执行的文件，如果找到文件，会读取文件的前128个字节，判断文件的格式，也就是前文所说要根据魔数判断。当读取了这128个字节之后，就会调用search_binary_handle去搜索和匹配合适的可执行文件装载过程。

## 动态链接

静态链接会浪费空间，同一个目标文件会在不同的程序中有着相同的副本，另一个问题是更新部署发布也会出现麻烦，比如一个目标文件是由厂商提供，那么只要厂商一更新，整个程序都需要重新链接发布。要解决这两个问题就是把程序的模块相互分割开来形成独立的文件而不静态的链接在一起，即不对那些组成程序的目标文件进行链接而是等到程序运行时才进行链接。

在linux系统中，ELF动态链接文件被称为动态共享对象，一般是以.so为扩展名的一些文件，在window系统中，是以.dll为扩展名的文件。由于动态链接将链接的过程从装载前推迟到了装载的时候，因此相较于静态链接速度要稍慢一些。

可以使用以下的命令将lib.c编译成一个共享对象文件：

```shell
gcc -fPIC -shared -o Lib.so Lib.c
```

其中-shared表示产生共享对象。之后可以使用以下命令得到程序：

```shell
gcc -o Program1 Program1.c ./Lib.so
gcc -o Program2 Program2.c ./Lib.so
```

在动态链接下，程序被分成了若干文件，有程序的主要部分，即可执行文件和程序所依赖的共享对象，可执行文件和共享对象都可以看作是程序的一个模块。

在链接成可执行文件时，链接器必须确定Program1.o中所引用的foobar函数的性质，如果foobar是一个定义在其他静态目标模块中的函数，那么链接器会将foobar地址引用重定位，如果boobar是一个定义在共享对象中的函数，链接器会将这个符号的引用标记为一个动态链接的符号，不对它进行地址重定位，把这个过程留到装载时进行。如果查看这个程序的虚拟内存分布，就会发现，除了Program1和Lib.so之外，还有一个共享对象ld-2.6.so，它实际上是linux下的动态链接器。当程序开始运行时，首先会把控制器交给动态链接器，由它完成动态链接工作后再把控制器交给Program1。

回顾一下第二章，程序模块的指令和数据中可能会包含一些绝对地址的引用，我们在链接产生输出文件的时候，就要假设模块被装载的目标地址。很明显，在动态链接的情况下，如果不同模块目标装载地址都一样是不行的。原来，可以手工指定各个模块的地址，这种做法叫做静态共享库，可能导致地址的冲突。静态共享库的做法就是将程序的各个模块统一交给操作系统来处理，操作系统在某个特定的地址划分出一些地址块，为那些已知的模块预留足够的空间。除了地址冲突外，静态共享库的升级也很成问题，因为升级后的共享库必须保持共享库中全局函数和变量地址的不变，如果程序在链接时绑定了这些地址，一旦更改，就必须重新链接程序。要想解决这个问题，那就必须假设共享对象在编译时不能假设自己在进程虚拟空间中的位置。为了做到这一点，那么在链接时，对所有绝对地址的引用不做重定位，而把这一步推迟到装载时再完成，一旦模块装载地址确定，那么系统就对程序中所有的决定地址引用进行重定位。

装载时重定位是解决动态模块中有绝对地址引用的办法之一，但其有一个很大的缺点是指令部分无法在多个进程之间共享。我们的目的很简单，就是希望共享的指令部分在装载时不需要因为装载地址的改变而改变，所以解决方法就是把指令中那些需要被修改的部分分离出来跟数据部分放在一起，这样指令部分就可以保持不变，数据部分则是每个进程中拥有一个副本，这种方法就是目前被称为地址无关代码的技术。要实现地址无关的代码，需要先分析模块中各种类型的地址引用方式，这里把共享对象模块中的地址引用按照是否跨模块分成两类：模块内部引用和模块外部引用，按照不同的引用方式又分为指令引用和数据访问，这样就得到了以下的四种情况：

- 第一种是模块内部的函数调用、跳转等；
- 第二种是模块内部的数据访问，比如模块中定义的全局变量、静态变量等；
- 第三种是模块外部的函数调用、调整等；
- 第四种是模块外部的数据访问，比如其他模块中定义的全局变量；

第一种最为简单，因为调用的函数与调用者位于同一模块，相对位置固定，对于现代操作系统来说，模块内部的跳转跟函数调用可以是相对地址调用或者是基于寄存器的相对调用，所以这种指令是不需要重定位的。第二种情况下，很明显，指令中不能直接包含数据的绝对地址，那么唯一的方法就是相对寻址，我们知道，一个模块前面一般是若干个页的代码，后面跟着若干个页的数据，这些页之间的相对位置是固定的，也就是说任何一条指令与它需要访问的模块内部数据之间的相对位置是固定的，那么只需要相对于当前指令加上固定的偏移量就可以访问模块内部数据了，现代的体系中，数据的相对寻址往往没有相对与当前指令地址（PC）的寻址方式，所以ELF用了一个巧妙的办法来得到当前的PC值，然后再加上一个偏移量就可以达到访问相应变量的目的。第三种稍微麻烦点，因为模块间的数据访问目标地址要等到装载时才能决定，根据前面提到的代码地址无关，要把跟地址相关的部分放到数据段，ELF的做法是在数据段里建立一个指向这些变量的指针数组，也被称为全局偏移表（GOT），当代码需要引用该全局变量时，可以通过GOT由相对应的项间接引用。模块间的调用与跳转也可以采用类型三的方法来解决，不同的是GOT中相应的项保存的是目标函数的地址。要产生地址代码无关的代码很简单，使用-fPIC参数即可。如何区分一个DSO是否为PIC，可以使用以下命令：readelf -d foo.so | grep TEXTREL，如果有任何输出，那么就不是PIC的，因为TEXTREL代表代码段重定位表地址。地址无关代码技术也可以用于可执行文件，一个以地址无关方式编译的可执行文件称为地址无关可执行文件（PIE），产生的方式是-fPIE。

考虑一种特殊情况，当一个模块引用了一个定义在共享对象的全局变量的时候，比如module.c中使用extern引用全局变量global时，编译器在编译它时无法根据上下文判断是否为跨模块间调用。假设module.c是可执行文件的一部分，这种情况下由于程序主模块的代码并不是地址无关代码，也就是代码不会使用这种类似PIC的机制。由于可执行文件在运行时并不进行代码重定位，那么变量的地址必须在链接过程中确定下来，链接器会在创建可执行文件时在它的.bss段创建一个global变量的副本，会出现这样一个问题，global变量定义在原来的对象中，而在.bss段中还有一份，这在程序运行中显然不可行。解决方法只有一个，那就是把所有使用这个变量的指令都指向位于可执行文件中的那个副本。ELF共享库在编译时，默认把定义在模块内部的全局变量当作定义在其他模块的全局变量，也就是当作前面的类型四，通过GOT实现变量的访问，当共享模块被装载时，如果某个全局变量在可执行文件中拥有副本，那么动态链接器会将GOT中的相应地址指向该副本，如果变量在共享模块中被初始化，那么还需要把该初始值复制到主模块中的变量副本。如果module.c是一个共享对象的一部分，那么编译器在-fPIC情况下会把global的调用按照跨模块模式产生代码，因为即使是模块内部的，按照上面的结论还是会产生跨模块代码。

下面再看数据段有没有类似的绝对地址引用问题，例如如下的代码：

```c++
static int a;
static int* p = &a;
```

如果某个共享对象有这样的代码，那么指针p的地址就是一个绝对地址，它指向变量a，而变量a的地址会随着共享对象装载的地址的变化而变化。当装载到进程时，该地址即会固定，所以可以选择装载时重定位的方式来解决问题。对于共享对象来说，如果数据段中有绝对地址引用，编译器和链接器就会产生一个重定位表，这个表里包含“R_386_RELATIVE”类型的重定位入口。当发现这个入口，那么动态链接器就会对其进行重定位。实际上，也可以让代码段也使用这种方法，而不使用地址无关代码，只需要不使用-fPIC参数即可，但正如前面的讨论，如果代码不是地址无关的，它就不能被多个进程共享，也就失去了节省内存的优点。但装载时重定位的共享对象的运行速度要快于使用地址无关代码的共享对象，因为它省去了地址无关代码中每次访问全局数据和函数时需要做一次计算当前地址以及简介地址寻址的过程。对于可执行文件来说，默认情况下如果可执行文件是动态链接的，那么GCC会使用PIC的方法来产生可执行文件的代码段部分，以便不同的进程能够共享代码段，节省内存。加

经过以上分析，动态链接要比静态链接要慢一些，一方面在于动态链接下对于全局和静态的数据访问都需要进行复杂的的GOT定位，然后间接寻址，对于模块间的调用也要先定位GOT，然后再进行间接跳转，另外一方面在于动态链接的链接工作在运行时完成，其会寻找并装载所需要的共享对象，然后进行符号查找地址重定位等。下面要介绍的就是一些优化的方法。在动态链接之下，程序模块之间包含了大量的函数引用，符号查找以及重定位正如前面说的会耗费大量的时间，但实际上很多函数都不会用到，如果一开始就把所有函数链接好是一种浪费，所以ELF采用了一种延迟绑定的做法，即当函数第一次被用到时才进行绑定（符号查找定位等）。ELF使用PLT（Procedure Linkage Table）的方法来实现。假设现在我们要进行函数绑定，起码知道模块的名称以及函数的名字，假设通过lookup函数来完成地址绑定，实际上在Glibc中，这个lookup函数的名字叫做\_dl\_runtime_resolve()。PLT为了实现延迟绑定，其调用函数并不直接通过GOT跳转，而是通过PLT项。每个外部函数在PLT中都有一个相应的项，这个项的第一条指令是通过GOT间接跳转的指令，由于为了实现延迟绑定，实际的地址并没有填入该项，而是将第二条指令"push n"填入，这样就会将一个数字n压入堆栈，这个数字是被调用函数这个符号引用在重定位表.rel.plt中的下标，接着又是一条push指令，将模块ID压入堆栈，然后调用动态链接器的\_dl\_runtime_resolve完成符号的解析和重定位，之后会把被调用函数的真正地址填入，这样下次调用第一条指令会直接跳转。

下面介绍一下动态链接的相关结构。动态链接下可执行文件跟静态链接情况一样，首先系统会读取可执行文件的头部，检查文件的合法性，然后从头部的program header中读取每个segment的虚拟地址、文件地址和属性，并将他们映射到进程空间的对应位置，静态链接情况下这之后系统会把控制权交给可执行文件的入口地址，然后程序开始执行，但动态链接情况下，可执行文件中很多外部符号的引用还处于无效地址的状态，所以需要启动一个动态链接器。动态链接器位置由ELF可执行文件决定，有一个专门的段.interp段，使用以下命令可以看到它的内容objdump -a a.out。这里面的内容很简单，就是一个字符串，保存着动态链接器的路径，在linux下几乎都是"/lib/ld-linux.so.2"。动态链接器在linux下是Glibc的一部分，其版本号往往与glibc的库版本号一致。.dynamic段保存了动态链接器所需要的基本信息，比如依赖哪些共享对象、动态链接符号表的位置、动态链接重定位表的位置、共享对象初始化代码等。使用readelf工具可以查看其内容：readelf -d Lib.so，linux还提供了一个命令来查看一个共享库依赖哪些共享库：ldd program1。.dynsym保存了与动态链接相关的符号，对于模块内部的符号比如私有变量则不保存。rel.dyn与.rel.plt相当于.rel.text和.rel.data，前者是对数据引用的修正，所修正的位置位于.got和数据段，后者是对函数引用的修正，修正的位置位于.got.plt，可以用readelf查看一个动态链接文件的重定位表：readelf -r Lib.so。堆栈还保存了动态链接器所需要的一些辅助信息数组，其格式也是一个结构数组，被定义在elf.h中，这个辅助信息数组的结构位于环境变量指针的后面。

有了上面的基础，可以分析动态链接的实际链接步骤，基本分为三步：先是启动动态链接器本身，然后装载所有需要的共享对象，最后是重定位和初始化。动态链接器本身也是一个共享对象，但其本身有些特殊，不可以依赖于其他任何共享对象，且本身所需要的全局变量和静态变量的重定位工作由自身完成。第一个条件可以人为的保证，第二个条件则必须在启动时有一段非常精巧的代码可以完成但又不能用到全局和静态变量，这种具有一定限制条件的启动代码往往称为自举动态链接器入口即是自举代码的入口，当开始执行时，自举代码首先找到自己的GOT，GOT的第一个入口即是.dynamic段的偏移地址，通过.dynamic段中的信息，自举代码代码便可以获得动态链接器本身的重定位表和符号表等，从而得到动态链接器本身的重定位入口，先将它们全部重定位，之后才可以使用自己的全局变量和静态变量，才可以调用函数。

完成自举之后，动态链接器将可执行文件和自身的符号表合并成一个符号表，可以称之为全局符号表，之后链接器寻找可执行文件所依赖的共享对象，将共享对象的名字放入到一个装载集合，然后可以挨个打开相应文件，将其相应的代码段和数据段映射到进程空间。

当上面的步骤完成之后，链接器可以遍历可执行文件和每个共享对象的重定位表，将它们的GOT/PLT中的每个需要重定位的位置进行修正。

支持动态链接的系统往往都支持显式运行时加载，有时也叫运行时加载，即让程序在运行时控制加载指定的模块，可以在不需要的时候将其卸载。动态库的装载需要通过一系列动态链接器的API，具体来讲有4个函数：打开动态库（dlopen）、查找符号（dlsym）、错误处理（dlerror）、以及关闭动态库（dlclose）。dlopen用来打开一个动态库并将其加载到进程的地址空间，其定义为`void *dlopen(const char* \*  filename, int flag)`。dlsym是运行时装载的核心，可通过这个函数找到所需要的符号，定义如下`void \* dlsym(void \*handle, char \*symbol)`；dlerror用于判断上一次调用是否成功，而dlclose与dlopen作用相反，是将一个已加载的模块卸载。

## Linux共享库的组织

共享库非常方便，但共享库也时常更新，这里更新分为两类，分别为兼容更新与不兼容更新，这里的兼不兼容一般指ABI是否会变化。比如C的共享库，导致C的共享库ABI的改变的行为主要有四种：导出函数的行为发生改变，即调用这个函数以后产生的结果与以前不一样；导出函数被删除；导出数据结构发生变化；导出函数的接口发生变化。C++则更为复杂，为了防止ABI不兼容，需要遵循以下准则：

- 不要在接口类中使用虚函数，万不得已使用时，不要随意删除、添加或在子类中增加新的实现函数，这样会导致类的虚函数表结构发生变化；
- 不要改变类中任何成员变量的位置和类型；
- 不要删除非内嵌的public或protected成员函数；
- 不要将非内嵌的成员函数改变成内嵌成员函数；
- 不要改变成员函数的访问权限；
- 不要在接口中使用模块；
- 不要改变接口的任何部分或干脆不要使用C++作为共享库接口；

版本库有着自己的命名规则，比如libname.so.x.y.z，x就表示主版本号，y表示次版本号，z表示发布版本号。主版本号表示重大升级，不同主版本号的库之间不兼容；次版本号表示增量升级，即增加一些新的接口符号，且保持原来的符号不变，在主版本号相同的情况下高的次版本号兼容低的；发布版本号表示库的一些错误的修正以及性能的改进。

动态链接器在进行动态链接时只进行主版本号的判断，即只判断SO-NAME，如果某个被依赖的共享库SO-NAME与系统中存在的世纪共享库SO-NAME一致，那么就认为版本兼容，而不进行兼容检查，实际上，会出现程序运行于较高的此版本库而当前的此版本库较低，可能会出现缺少某些符号的错误，现代系统采用符号版本机制来解决。此方案的基本思路是让每个导出和导入的符号都有一个相关联的版本号，类似名称修饰，当我们将libfoo.so.1.2升级到1.3时，仍然保持libfoo.so.1这个SO-NAME，但新添加的全局符号会打上一个标记，比如“VERS_1.3”，所有这样的标记的符号构成了一个符号的集合，这个集合向后兼容。当程序运行时，动态链接器会记录它所依赖的所有共享库的符号集合版本信息，然后判定当前系统共享库中的符号集合版本是否满足兼容要求。

在linux中，/lib这个位置主要存放系统最关键和基础的共享库，比如动态链接器、C语言运行库、数学库等，这些库主要是/bin和/sbin下的程序要用到的库，还有就是系统启动时需要的库；/usr/lib主要保存一些非系统运行时所需要的关键性的共享库；/usr/local/lib用来放一些跟操作系统本身不太相关的库，主要是一些第三方的应用程序库。/etc/ld.so.conf是一个文本配置文件，可能包含其他的配置文件，这些配置文件中存放着共享库的目录信息。

改变共享库查找路径最简单的方法是使用LD_LIBRARY_PATH环境变量，这个方法可以临时改变某个程序的共享库查找路径而不会影响其他程序；LD_PRELOAD这个环境变量用来预先装载一些共享库或者目标文件；LD_DEGUB用来打开调试功能。

创建共享库除了使用原来说的-shared和-fPIC，还有一个参数-W1，其用来将指定参数传递给链接器。如果我们希望共享库在装载时能够进行一些初始化操作，可以在函数声明时添加"\_\_attribute\_\_((constructor))"属性，这种函数在main函数执行之前执行，如果可以想要确定优先级，可以这样写"\_\_attribute\_\_((constructor(5)))"，对于构造函数而言，数字越小，优先级越高，析构函数则相反。

## 内存

现代应用程序都运行在一个内存空间里，在32位的系统里，这个空间的大小为4GB（2的32次方）。但是，这一部分空间会给内核使用，程序无法直接访问这段内存，这样的内存被称为内核空间。Windows默认情况下会将高地址的2GB分配给内核，Linux默认将高地址的1GB分配给内核。剩下的空间称为用户空间，一般分为如下的区域：

- 栈：用于维护函数调用的上下文，离开了栈函数调用就无法实现

- 堆：用来容纳程序动态分配的区域，堆通常位于栈的下方（低地址区域），在某些时候，也可能没有固定统一的存储区域，堆一般比栈大很多，可以有几十到数百兆字节的容量；
- 可执行文件映像：存储可执行文件在内存中的映像；
- 保留区：不是单一的区域，是内存中受到保护而禁止访问的内存区域的总称，例如一些极小的地址。

在内存中，还有一个没有介绍的区域：动态链接库映射区，用于映射装载的动态链接库，在linux中，如果可执行文件依赖其他共享库，那么系统就会从它在0x40000000开始的地址分配相应的空间，并将共享库载入到该空间。另外需要注意的是，栈向低地址增长，堆向高地址增长。

栈在程序运行中有着举足轻重的地位，其保存了一个函数调用所需要的维护信息，常常被称为堆栈帧或活动记录，堆栈帧一般包括如下的内容：

- 函数的返回地址和参数；
- 临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量；
- 保存的上下文：包括在函数调用前后需要保持不变的寄存器；

在i386中，一个函数的活动记录通过ebp和esp两个寄存器划定范围，esp寄存器始终指向栈的顶部，同时也就指向了当前函数的活动记录的顶部，ebp寄存器指向函数活动记录的一个固定位置，ebp寄存器又被称为帧指针。esp始终指向栈顶，跟着函数的执行而变换，而ebp则固定不变，在其之前是函数的返回地址，为ebp-4，再往前是压入栈中的参数，分别为ebp-8、ebp-12等。一个i386下的函数总是如下执行：

- 把所有或一部分参数压入栈，如果有其他参数没有入栈，则使用某些特定的寄存器传递；
- 把当前指令的下一条指令的地址压入栈中；
- 跳转到函数体执行；

调用惯例一般会规定以下几个方面的内容：

- 函数参数的传递顺序和方式；
- 栈的维护方式；
- 名字修饰的策略；

对于返回值，几乎所有的调用惯例都是采用eax和edx联合返回的方式进行的，其中eax存储返回值要低4字节，edx存储返回值要搞1-4字节。其传递过程用一个例子来说明：

- 首先main函数在栈上额外开辟了一片空间，并将这块空间的一部分作为传递返回值的临时对象，这里称为temp；
- 将temp对象的地址作为隐藏参数传递给return_test函数；
- return_test函数将数据拷贝给temp对象，并将temp对象的地址用eax传出；
- return_test函数返回之后，main函数将eax指向的temp对象的内容拷贝给n；

C++的返回值优化可以将对象直接构造在临时对象上，这样可以减少一次复制的过程。

对于堆空间，一般是由运行库管理，运行库相当于向操作系统批发了一块较大的堆空间，然后零售给程序使用。在进程的地址空间中，除了可执行文件、共享库和栈之外剩余未分配的空间都可以作为堆空间。linux下提供了两种堆空间分配的方式，即两个系统调用：一个是brk()系统调用，一个是mmap()系统调用。

brk的声明如下：

```c
int brk(void* end_data_segment)
```

其作用实际上是设置进程数据段的结束地址，即它可以扩大或缩小数据段。

mmap的作用是向操作系统申请一段虚拟地址空间，当然这块虚拟地址空间可以映射到某个文件，当它不将地址空间映射到某个文件时，这块空间就是匿名空间，匿名空间就可以拿来作为堆空间，声明如下：

```c
void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);
```

前两个参数用于指定需要申请的空间的起始地址和长度，如果起始地址设置为0，那么linux会自动挑选合适的起始地址，prot/flags两个参数用于设置申请空间的权限以及映射类型。glic的malloc函数在处理用户申请空间的请求时，对于小于128kb的，会在现有的堆空间中分配，大于的则会使用mmap分配一块匿名空间再在这个空间中分配。

堆分配算法主要有空闲链表、位图以及对象池三种。

## 运行库

一个典型的程序运行步骤大致如下：

- 操作系统创建进程后将控制权交给程序的入口，这个入口往往是运行库中的某个入口函数；
- 入口函数对运行库和程序运行环境进行初始化，包括堆、I/O、线程、全局变量构造等等；
- 入口函数在完成初始化之后调用main函数正式执行程序的主体部分；
- main函数执行完毕返回到入口函数，入口函数进行清理工作，包括全局变量析构、堆销毁、关闭I/O等，然后进行系统调用结束进程。

任何一个C程序要跑起来，都需要一套庞大的代码支撑，其至少包括入口函数，及其所依赖函数所构成的函数集合，还包括了各种标准库函数的实现，这样的一个代码集合称为运行时库，而C语言的运行库被称为C运行库（CRT）。

C语言的标准库非常轻量，包含很多内容，下面仅介绍两组特殊函数的细节。第一个是变长参数，函数声明如下：

```c
int printf(const char* format, ...);
```

这样声明表示除了第一个参数为const char*之外，后面可以追加任意数量、任意类型的参数，在函数的实现中，可以使用stdarg.h中的多个宏来访问各个额外的参数：假设lastarg是变长参数中最后一个具名参数，那么在函数内部定义类型为va_list的变量：

```c
va_list ap;
va_start(ap, lastarg);
type next = va_arg(ap, type);
```

该变量以后将依次指向各个可变参数，ap必须用宏va_start初始化一次，此后可以使用va_arg宏来获取下一个不定参数，最后记得用va_end清理现场。变长参数的实现得益于C语言默认的自右向左压栈传递方式。

第二个是非局部跳转，其可以实现从一个函数体向另一个实现登记过的函数体内跳转，而不用担心堆栈混乱，有以下的例子：

```c
#include <setjmp.h>
#include <stdio.h>
jmp_buf b;
void f() {
	longjmp(b, 1);
}

int main() {
	if (setjmp(b)) printf("World!");
	else {
		printf("Hello ");
		f();
	}
}
```

当setjmp正常返回时会返回0，此时打印Hello，进入f中，由于longjmp的作用会将流程倒回至setjmp返回的时刻，并返回第二个参数1，因此此时打印World。

线程也有自己的私有存储空间，包括：栈、线程局部存储以及寄存器。如果想要定义一个全局变量为线程私有，则需要用到线程局部存储（TLS，Thread Local Storage），这个机制很简单，只需要对需要私有的变量加上相应的关键字，对GCC来说，这个关键字是\_\_thread， 对于MSVC来说，对应为\_\_declspec(thread)。

## 系统调用与API

c语言形式的系统调用被定义在/usr/include/unistd.h中。linux系统中，使用0x80来触发所有的系统调用。当进行系统调用时，系统调用号由eax传入，然后使用int 0x80调用中断，中断服务系统就可以从eax中取得系统调用号进而调用对应的函数。

当调用一个系统调用时，是以一个函数的形式调用的，例如fork，其是一个对系统调用fork的封装，可以采用以下的宏来定义它：

```c
_syscall0(pid_t, fork);
```

当程序调用0x80号中断时，程序的执行流程从用户态切换到内核态，这时当前栈也需要从用户栈切换到内核栈。所谓的当前栈，指的是ESP的值所在的栈空间，如果ESP的值位于用户栈的范围内，那么程序的当前栈就是用户栈，反之亦然。此外，寄存器SS的值还应该指向当前栈所在的页。所以当前栈从用户栈切换到内核栈就是：

1. 保存当前的ESP、SS的值；
2. 将ESP、SS的值设置为内核栈的相应值；

反过来将内核栈切换回用户栈就是：

1. 恢复原来ESP、SS的值；

linux在2.5开始支持一种新型的系统调用机制sysenter和sysexit。调用sysenter之后系统会直接跳转到由某个寄存器指定的函数执行，并自动完成特权级转换、堆栈切换功能。



