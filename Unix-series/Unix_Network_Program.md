# 简介

## 概述

IPC是进程间通信的简称。在Unix过去30多年的演变中，消息传递经过了以下几个发展阶段：

- 管道，第一个广泛使用的IPC形式，既可以在程序中使用，又可以在shell使用。缺点是只能在具有共同祖先（指父子进程关系）的进程间使用，不过该问题已经被引入的FIFO（有名管道解决）；
- System V消息队列，可用在同一主机上有亲缘关系或无亲缘关系的进程之间。理论上说，所有Unix进程都跟init进程有亲缘关系，它是系统自举时启动所有初始化进程的祖先进程。
- Poxis消息队列；
- 远程过程调用（RPC），是从一个系统上某个程序调用；

## 进程线程与信息共享

进程之间信息共享有多种方式，按层级划分有如下关系：

![](..\image\Unix\2-1-1.png)

1. 进程共享文件系统中某个文件的信息，为了访问这些信息，每个进程都得穿越内核（例如read、write、lseek等）；
2. 共享的信息驻留在内核中，管道、System V消息队列、System V信号量都是如此；
3. 共享的信息存在一个双方都能访问的内存区；

## IPC对象的持续性

可以将任意类型的IPC的持续性定义成该类型的一个对象一直存在多长时间，如：

![](..\image\Unix\2-1-2.png)

1. 随进程持续的有管道和FIFO；
2. 随内核持续的有System V的消息队列、信号量和共享内存区；
3. 随文件系统持续的有如果是用映射文件的Posix消息队列、信号量和共享内存区；

各种类型IPC对象的持续性如下所示：

![](..\image\Unix\2-1-3.png)

## fork、exec和exit对IPC对象的影响

总结如下：

![](..\image\Unix\2-1-6.png)

# Posix IPC

## 概述

Posix IPC由Posix消息队列、Posix信号量、Posix共享内存区组成。相关函数总结如下：

![](..\image\Unix\2-2-1.png)

# System V IPC

## 概述

System V消息队列、System V信号量、System V共享内存区合称为System V IPC；其函数汇总如下：

![](..\image\Unix\2-3-1.png)

## 创建与打开IPC通道

创建或打开一个IPC对象的三个getxxx函数，第一个参数是类型为Key_t的IPC键，返回值identifier是一个整数标识符。对于key值有两个选择：

1. 调用ftok，传递pathname和id；
2. 指定key为IPC_PRIVATE，会保证创建一个新的、唯一的IPC对象；

其oflag的参数规则如下：

- 没有一对id和pathname的组合会产生IPC_PRVATE这个键值；
- 设置oflag参数的IPC_CREATE位但不设置IPC_EXCL位时，如果指定键的IPC对象不存在会创建，否则返回该对象；
- 同时设置oflag的IPC_CREAT和IPC_EXCL位时，如果指定键的IPC对象不存在就创建一个新的对象，否则返回一个EEXIST错误，因为该对象已存在；

## IPC权限

每创建一个新的IPC对象，以下信息就会保存到ipc_perm结构中：oflag参数中某些初始化ipc_perm结构的mode成员，表示了一些读写权限；cuid和cgid；uid和gid；

## 标识符重用

ipc_perm结构中还含有一个名为seq的变量，它是一个槽位使用情况序列号，是一个内核为系统中每个潜在的IPC对象维护的计数器。每当删除一个IPC对象时，内核就递增相应的槽位号，溢出则返回0；

该计数器的存在有两个原因。由于本章所述的IPC是系统级，如果采用小正数，很容易被一些进程试出来恶意操作IPC，因此IPC机制的设计者将标识符的可能范围扩大到所有的整数，这种扩大是这么实现：每次重用一个IPC表项时，把返回给调用进程的标识符值增加一个IPC表项数，例如系统配置最多50个消息队列，那么内核中第一个消息队列被删除且重用时，返回的标识符不再是0而是变成50。递增槽位使用情况序列号的另一个原因是为了避免短时间重用System V IPC标识符。

# 管道和FIFO

## 管道

所有的Unix都提供管道，由pipe函数创建，提供一个单路数据流。一个管道返回两个文件描述符，`fd[0]`打开读，`fd[1]`打开来写。宏S_ISFIFO可用来确定一个描述符或文件是管道还是FIFO。管道的使用情况一般是一个进程创建管道，然后调用fork派生一个自身的副本，之后父进程关闭这个管道的读出端，子进程关闭同一管道的写入端，这样就在父子进程之间提供了一个单向的数据流，如图：

![](..\image\Unix\2-4-4.png)

注意为子进程waitpid，因为子进程在管道写入最终数据后调用exit首先终止，它随后变成一个僵尸进程：自身已终止但父进程仍在运行且尚未等待该子进程的进程。当子进程终止时，内核还给父进程一个SIGCHLD信号，但父进程没有捕获这个信号，该信号的默认行为就是忽略。之后不久，父进程在从管道读取最终数据后返回，随后调用waitpid取得已终止子进程（僵尸进程）的终止状态。如果父进程没有调用waitpid，而是直接终止，那么子进程将成为托孤给init进程的孤儿进程，内核将向init进程发送另一个SIGCHLD信号，init进程随后取得该僵尸进程的终止状态。

## 全双工管道

某些系统提供全双工管道：SVR4的pipe函数以及许多内核都提供的socketpair函数。全双工管道的真实实现如下：

![](..\image\Unix\2-4-13.png)

## popen和pclose函数

作为另一个关于管道的例子，标准I/O函数库提供了popen函数，其创建一个管道并启动另一个进程，该进程要么从该管道读取标准输入，要么往该管道写入标准输出。

## FIFO

FIFO称为有名管道，由mkfifo创建。再创建出一个FIFO之后，必须打开来读或者打开来写，所用的可以是open或者fopen。FIFO不能打开既读又写，因为它是半双工的。

管道在所有进程最终都关闭它之后自动消失，FIFO的名字则只有通过调用unlink才从文件系统中删除。

unlink尽管可以从文件系统删除指定的路径名，但先前已经打开该路径名、目前仍打开着的描述符却不受影响。

## 管道和FIFO的额外属性

一个描述符能以两种方式设置成非阻塞：

1. 调用open时指定O_NONBLOCK标志：

   ```
   writefd = Open(FIFO1, O_WRONLY | O_NONBLOCK, 0);
   ```

   

2. 如果一个描述符已经打开，可以调用fcntl启用O_NONBLOCK标志，对于管道来说必须使用这种技术，因为其没有open调用，在pipe调用中也无法启动，示例：

   ```c++
   int flags;
   if ((flags = fcntl(fd, F_GETFL, 0)) < 0)
   	err_sys("F_GETFL error");
   flags |= O_NONBLOCK;
   if ((flags = fcntl(fd, F_SETFL, flags)) < 0)
   	err_sys("F_SETFL error");
   ```

   建议使用以上方式，防止简单设置标志而将原来的设置清空。

非阻塞标志的影响如下：

![](..\image\Unix\2-4-21.png)

以下是关于管道或FIFO的读写的若干额外规则：

- 如果请求读出的数据量多于管道或FIFO当前可用数据量，那么只返回这些可用数据；

- 如果请求写入的数据的字节数小于或等于PIPE_BUF（一个Posix限制值），那么write操作保证是原子的。如果大于PIPE_BUF，那么就不能保证。*Posix.1要求PIPE_BUF至少为512字节，常见的值处于1024到5120之间。*

- O_NONBLOCK对write操作的原子性没有影响。但如果设置成非阻塞时，来自write的返回值取决于待写的字节数以及该管道或FIFO中当前可用空间大小。如果待写字节数小于等于PIPE_BUF：

  1. 如果有足以存放所请求字节数的空间，那么所有数据写入。
  2. 如果没有足够的空间，那么立即返回一个EAGAIN错误。

  如果待写的字节数大于PIPE_BUF:

  1. 有空间写多少返回多少。
  2. 如果没有空间返回一个EAGAIN错误。

- 如果向一个没有为读打开着的管道或FIFO写入，内核将产生一个SIGPIPE信号：
  1. 如果调用进程既没有捕获也没有忽略该信号，那么默认行为就是终止该进程。
  2. 如果调用进程忽略了该信号或者捕获了该信号并从信号处理程序中返回，那么write返回一个EPIPE错误。

## 对比迭代服务器与并发服务器

默认情况下当客户还没有打开字节的FIFO时，服务器是阻塞在对该FIFO的open调用，这意味着恶意的客户可以让服务器处于停顿状态，方法是发送一个请求却不打开字节的FIFO来读，这称为拒绝服务（DoS）型攻击。为避免这种攻击，要留意服务器可能在哪阻塞以及可能阻塞多久。处理这种问题方法之一是在特定操作设置一个超时时钟，但把服务器程序变成并发服务器更为简单。

## 字节流与消息

如果想要识别消息的边界，可以采用以下的技巧：

1. 带内特殊终止序列：比如以换行符来分隔消息。
2. 显式长度：每个记录前冠以它的长度；
3. 每次连接一个记录：应用通过关闭与其对端的连接来指示一个记录的结束；

## 管道和FIFO限制

系统给与管道和FIFO的唯一限制为：

OPEN_MAX：一个进程在任意时刻打开的最大描述符数（Posix要求至少为16）；

PIPE_BUF：可原子写往一个管道或FIFO的最大数据量；

OPEN_MAX的值可通过sysconf函数查询，可通过ulimit或limit命令从shell修改，也可通过调用setrlimit函数从一个进程中修改。PIPE_BUF的值可以在运行时通过调用pathconf或fpathconf取得。

# Posix消息队列

## 概述

Posix消息队列和System V消息队列的差别如下所示：

- Posix消息队列的读总是返回最高优先级的最早消息，对System V消息队列的读则可以返回任意指定优先级的消息；
- 当往一个空队列放置一个消息时，Posix消息队列允许产生一个信号或启动一个线程，System V消息队列则不提供类似机制；

队列中的每个消息具有如下属性：

- 一个无符号整数优先级（Posix）或一个长整数类型（System V）；

- 消息的数据部分长度（可以为0）；
- 数据本身；

## mq_open、mq_close和mq_unlink

mq_close可以关闭一个mq_open打开的消息队列，但其消息队列并不从系统删除。要从系统中删除就必须调用mq_unlink。每个消息队列有一个保存其打开着的描述符数的引用计数器，因此能够实现类似于unlink函数删除一个文件的机制：当一个消息队列的引用技术仍大于0，其能够执行删除操作，但析构要到最后一个mq_close发生时才进行。getopt函数用来解析传入到进程的参数。

## mq_send和mq_receive函数

这两个函数分别用于往一个队列中放置一个消息和从一个队列中取走一个消息。每个消息有个优先级，它是一个小于MQ_PRIO_MAX的无符号整数，Posix要求这个上限至少为32。mq_receive总是返回所指定队列中最高优先级的最早消息，而且该优先级能随该消息的内容及长度一同返回。

## 消息队列限制

创建队列时会建立两个限制：

- mq_maxmsg：队列中最大消息数
- mq_msgsize：给定消息的最大字节数

消息队列的实现定义了两位两个限制：

- MQ_OPEN_MAX：一个进程能够同时拥有的打开着消息队列的最大数目（Posix要求至少为8）；
- MQ_PRIO_MAX：任意消息的最大优先级值加一（Posix要求至少为32）；

## mq_notify函数

Posix消息队列允许异步事件通知，告知何时有一个消息放到了某个空消息队列中，这种通知有两种方式选择：

- 产生一个信号；
- 创建一个线程来执行一个特定的函数；

这种通知通过调用mq_notify建立。任意时刻只有一个进程可以被注册为接受某个队列的通知，且接收到通知之后这种注册即被取消。注意，在mq_receive调用中的阻塞比任何通知的注册都优先。

注意，信号处理函数中只可调用异步信号安全的函数，所有标准I/O函数和pthread_xxx都不在其中。本书涵盖的IPC函数中，只有sem_post、read和write在其中。